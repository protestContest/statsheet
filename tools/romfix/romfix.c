#include "../../inc/prefix.h"
#include <string.h>
#include <unistd.h>

typedef struct {
  u32 entry;
  u8 logo[156];
  char title[12];
  char gameCode[4];
  char makerCode[2];
  u8 fixed;
  u8 unitCode;
  u8 deviceType;
  u8 reserved[7];
  u8 version;
  u8 complement;
  u8 checksum[2];
} ROMHeader;

ROMHeader header = {
  0xEA00002E,
  { 0x24,0xFF,0xAE,0x51,0x69,0x9A,0xA2,0x21,0x3D,0x84,0x82,0x0A,0x84,0xE4,0x09,0xAD,
    0x11,0x24,0x8B,0x98,0xC0,0x81,0x7F,0x21,0xA3,0x52,0xBE,0x19,0x93,0x09,0xCE,0x20,
    0x10,0x46,0x4A,0x4A,0xF8,0x27,0x31,0xEC,0x58,0xC7,0xE8,0x33,0x82,0xE3,0xCE,0xBF,
    0x85,0xF4,0xDF,0x94,0xCE,0x4B,0x09,0xC1,0x94,0x56,0x8A,0xC0,0x13,0x72,0xA7,0xFC,
    0x9F,0x84,0x4D,0x73,0xA3,0xCA,0x9A,0x61,0x58,0x97,0xA3,0x27,0xFC,0x03,0x98,0x76,
    0x23,0x1D,0xC7,0x61,0x03,0x04,0xAE,0x56,0xBF,0x38,0x84,0x00,0x40,0xA7,0x0E,0xFD,
    0xFF,0x52,0xFE,0x03,0x6F,0x95,0x30,0xF1,0x97,0xFB,0xC0,0x85,0x60,0xD6,0x80,0x25,
    0xA9,0x63,0xBE,0x03,0x01,0x4E,0x38,0xE2,0xF9,0xA2,0x34,0xFF,0xBB,0x3E,0x03,0x44,
    0x78,0x00,0x90,0xCB,0x88,0x11,0x3A,0x94,0x65,0xC0,0x7C,0x63,0x87,0xF0,0x3C,0xAF,
    0xD6,0x25,0xE4,0x8B,0x38,0x0A,0xAC,0x72,0x21,0xD4,0xF8,0x07 },
  { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
  { 0x00,0x00,0x00,0x00 },
  { '0', '0' },
  0x96,
  0x00,
  0x00,
  { 0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
  0x00,
  0x00,
  { 0x00,0x00 }
};

void Usage(void)
{
  fprintf(stderr, "Usage: romfix rom.gba [-t title] [-c code] [-m maker]\n");
  exit(1);
}

char *ParseOpts(int argc, char *argv[])
{
  int ch;
  char *filename = 0;

  while (optind < argc) {
    if ((ch = getopt(argc, argv, "t:c:m:")) >= 0) {
      switch (ch) {
      case 't':
        memcpy(header.title, optarg, Min(12, strlen(optarg)));
        break;
      case 'c':
        memcpy(header.gameCode, optarg, Min(4, strlen(optarg)));
        break;
      case 'm':
        memcpy(header.makerCode, optarg, Min(2, strlen(optarg)));
        break;
      default:
        Usage();
      }
    } else {
      if (filename) {
        Usage();
      }
      filename = argv[optind];
      optind++;
    }
  }

  if (!filename) {
    Usage();
  }

  return filename;
}

#define MB 1048576
void PadFile(FILE *f)
{
  int sizes[] = {
    1*MB,
    2*MB,
    4*MB,
    8*MB,
    16*MB,
    32*MB
  };
  char fill[1024] = {0xFF};
  int padding = 0;

  fseek(f, 0, SEEK_END);
  int fileSize = ftell(f);

  if (fileSize > 32*MB) {
    fprintf(stderr, "ROM too big\n");
    exit(2);
  }

  for (int i = 0; i < ArrayCount(sizes); i++) {
    if (sizes[i] == fileSize) break;
    if (sizes[i] > fileSize) {
      padding = sizes[i] - fileSize;
      break;
    }
  }

  if (padding > 0) {
    for (int i = 0; i < padding / ArrayCount(fill); i++) {
      fwrite(fill, ArrayCount(fill), 1, f);
    }
    fwrite(fill, padding % ArrayCount(fill), 1, f);
  }
}

u8 Checksum(void)
{
  u8 checksum = 0;
  for (u32 i = 0xA0; i < 0xBD; i++) {
    checksum += ((u8*)&header)[i];
  }
  return -(0x19 + checksum);
}

int main(int argc, char *argv[])
{
  char *filename = ParseOpts(argc, argv);

  FILE *f = fopen(filename, "r+b");
  if (!f) {
    fprintf(stderr, "File not found: \"%s\"\n", filename);
  }

  header.complement = Checksum();
  fwrite(&header, sizeof(header), 1, f);

  PadFile(f);
  fclose(f);

  return 0;
}
